[
  {
    "ID": "github.com/titpetric/exp/cmd/go-fsck/model",
    "Package": "model",
    "ImportPath": "github.com/titpetric/exp/cmd/go-fsck/model",
    "Path": ".",
    "TestPackage": false,
    "Imports": {
      "built_in_types.go": [
        "\"strings\""
      ],
      "declaration.go": [
        "\"go/ast\"",
        "\"strings\""
      ],
      "declaration_list.go": [
        "\"go/ast\"",
        "\"sort\"",
        "\"strings\""
      ],
      "definition.go": [
        "\"strings\""
      ],
      "package.go": [
        "\"fmt\"",
        "\"strings\"",
        "\"golang.org/x/tools/go/packages\""
      ],
      "ref.go": [
        "\"fmt\""
      ],
      "string_set.go": [
        "\"fmt\"",
        "\"path\"",
        "\"regexp\"",
        "\"slices\"",
        "\"sort\"",
        "\"strings\""
      ],
      "type_ref.go": [
        "\"strings\""
      ]
    },
    "Types": [
      {
        "Kind": "type",
        "File": "complexity.go",
        "Line": 3,
        "SelfContained": true,
        "Name": "Complexity",
        "Fields": [
          {
            "Name": "Cognitive",
            "Type": "int",
            "Path": "Complexity.Cognitive",
            "JSONName": "Cognitive"
          },
          {
            "Name": "Cyclomatic",
            "Type": "int",
            "Path": "Complexity.Cyclomatic",
            "JSONName": "Cyclomatic"
          },
          {
            "Name": "Lines",
            "Type": "int",
            "Path": "Complexity.Lines",
            "JSONName": "Lines"
          },
          {
            "Name": "Coverage",
            "Type": "float64",
            "Path": "Complexity.Coverage",
            "Doc": "Coverage is filled out of band (summary coverfunc).",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Coverage"
          }
        ],
        "Source": "type Complexity struct {\n\tCognitive\tint\n\tCyclomatic\tint\n\tLines\t\tint\n\n\t// Coverage is filled out of band (summary coverfunc).\n\tCoverage\tfloat64\t`json:\",omitempty\"`\n}"
      },
      {
        "Kind": "type",
        "File": "declaration.go",
        "Line": 9,
        "SelfContained": true,
        "Doc": "Declaration holds information about a go symbol.",
        "Name": "Declaration",
        "Fields": [
          {
            "Name": "Kind",
            "Type": "DeclarationKind",
            "Path": "Declaration.Kind",
            "JSONName": "Kind"
          },
          {
            "Name": "Type",
            "Type": "string",
            "Path": "Declaration.Type",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Type"
          },
          {
            "Name": "File",
            "Type": "string",
            "Path": "Declaration.File",
            "JSONName": "File"
          },
          {
            "Name": "Line",
            "Type": "int",
            "Path": "Declaration.Line",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Line"
          },
          {
            "Name": "SelfContained",
            "Type": "bool",
            "Path": "Declaration.SelfContained",
            "JSONName": "SelfContained"
          },
          {
            "Name": "Imports",
            "Type": "[]string",
            "Path": "Declaration.Imports",
            "Doc": "This is not encoded to json, it's computed on load.",
            "Tag": "json:\"-\"",
            "JSONName": ""
          },
          {
            "Name": "References",
            "Type": "StringSet",
            "Path": "Declaration.References",
            "Tag": "json:\",omitempty\"",
            "JSONName": "References"
          },
          {
            "Name": "Globals",
            "Type": "StringSet",
            "Path": "Declaration.Globals",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Globals"
          },
          {
            "Name": "Doc",
            "Type": "string",
            "Path": "Declaration.Doc",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Doc"
          },
          {
            "Name": "Name",
            "Type": "string",
            "Path": "Declaration.Name",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Name"
          },
          {
            "Name": "Names",
            "Type": "[]string",
            "Path": "Declaration.Names",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Names"
          },
          {
            "Name": "Receiver",
            "Type": "string",
            "Path": "Declaration.Receiver",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Receiver"
          },
          {
            "Name": "Fields",
            "Type": "FieldList",
            "Path": "Declaration.Fields",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Fields"
          },
          {
            "Name": "Arguments",
            "Type": "[]string",
            "Path": "Declaration.Arguments",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Arguments"
          },
          {
            "Name": "Returns",
            "Type": "[]string",
            "Path": "Declaration.Returns",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Returns"
          },
          {
            "Name": "Signature",
            "Type": "string",
            "Path": "Declaration.Signature",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Signature"
          },
          {
            "Name": "Source",
            "Type": "string",
            "Path": "Declaration.Source",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Source"
          },
          {
            "Name": "Complexity",
            "Type": "*Complexity",
            "Path": "Declaration.Complexity",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Complexity"
          }
        ],
        "Source": "// Declaration holds information about a go symbol.\ntype Declaration struct {\n\tKind\tDeclarationKind\n\tType\tstring\t`json:\",omitempty\"`\n\n\tFile\tstring\n\tLine\tint\t`json:\",omitempty\"`\n\n\tSelfContained\tbool\n\n\t// This is not encoded to json, it's computed on load.\n\tImports\t[]string\t`json:\"-\"`\n\n\tReferences\tStringSet\t`json:\",omitempty\"`\n\tGlobals\t\tStringSet\t`json:\",omitempty\"`\n\n\tDoc\tstring\t`json:\",omitempty\"`\n\n\tName\t\tstring\t\t`json:\",omitempty\"`\n\tNames\t\t[]string\t`json:\",omitempty\"`\n\tReceiver\tstring\t\t`json:\",omitempty\"`\n\n\tFields\tFieldList\t`json:\",omitempty\"`\n\n\tArguments\t[]string\t`json:\",omitempty\"`\n\tReturns\t\t[]string\t`json:\",omitempty\"`\n\n\tSignature\tstring\t`json:\",omitempty\"`\n\tSource\t\tstring\t`json:\",omitempty\"`\n\n\tComplexity\t*Complexity\t`json:\",omitempty\"`\n}"
      },
      {
        "Kind": "type",
        "File": "declaration_kind.go",
        "Line": 4,
        "SelfContained": false,
        "Doc": "DeclarationKind is an enum of go symbol types.",
        "Name": "DeclarationKind",
        "Source": "// DeclarationKind is an enum of go symbol types.\ntype DeclarationKind string"
      },
      {
        "Kind": "type",
        "Type": "[]*Declaration",
        "File": "declaration_list.go",
        "Line": 10,
        "SelfContained": false,
        "Doc": "DeclarationList holds a list of Go symbols.",
        "Name": "DeclarationList",
        "Source": "// DeclarationList holds a list of Go symbols.\ntype DeclarationList []*Declaration"
      },
      {
        "Kind": "type",
        "File": "definition.go",
        "Line": 6,
        "SelfContained": true,
        "Doc": "Definition holds all symbols defined for a Package.",
        "Name": "Definition",
        "Fields": [
          {
            "Name": "",
            "Type": "Package",
            "Path": "Definition",
            "JSONName": ""
          },
          {
            "Name": "Doc",
            "Type": "string",
            "Path": "Definition.Doc",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Doc"
          },
          {
            "Name": "Imports",
            "Type": "StringSet",
            "Path": "Definition.Imports",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Imports"
          },
          {
            "Name": "InitCount",
            "Type": "int",
            "Path": "Definition.InitCount",
            "Tag": "json:\",omitempty\"",
            "JSONName": "InitCount"
          },
          {
            "Name": "Types",
            "Type": "DeclarationList",
            "Path": "Definition.Types",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Types"
          },
          {
            "Name": "Consts",
            "Type": "DeclarationList",
            "Path": "Definition.Consts",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Consts"
          },
          {
            "Name": "Vars",
            "Type": "DeclarationList",
            "Path": "Definition.Vars",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Vars"
          },
          {
            "Name": "Funcs",
            "Type": "DeclarationList",
            "Path": "Definition.Funcs",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Funcs"
          }
        ],
        "Source": "// Definition holds all symbols defined for a Package.\ntype Definition struct {\n\tPackage\n\n\tDoc\tstring\t`json:\",omitempty\"`\n\n\tImports\t\tStringSet\t`json:\",omitempty\"`\n\tInitCount\tint\t\t`json:\",omitempty\"`\n\n\tTypes\tDeclarationList\t`json:\",omitempty\"`\n\tConsts\tDeclarationList\t`json:\",omitempty\"`\n\tVars\tDeclarationList\t`json:\",omitempty\"`\n\tFuncs\tDeclarationList\t`json:\",omitempty\"`\n}"
      },
      {
        "Kind": "type",
        "Type": "[]*Definition",
        "File": "definition_list.go",
        "Line": 4,
        "SelfContained": false,
        "Doc": "DefinitionList holds a list of Go packages.",
        "Name": "DefinitionList",
        "Source": "// DefinitionList holds a list of Go packages.\ntype DefinitionList []*Definition"
      },
      {
        "Kind": "type",
        "File": "field.go",
        "Line": 4,
        "SelfContained": true,
        "Doc": "Field holds details about a field definition.",
        "Name": "Field",
        "Fields": [
          {
            "Name": "Name",
            "Type": "string",
            "Path": "Field.Name",
            "Doc": "Name is the name of the field.",
            "JSONName": "Name"
          },
          {
            "Name": "Type",
            "Type": "string",
            "Path": "Field.Type",
            "Doc": "Type is the literal type of the Go field.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Type"
          },
          {
            "Name": "Path",
            "Type": "string",
            "Path": "Field.Path",
            "Doc": "Path is the go path of this field starting from root object.",
            "JSONName": "Path"
          },
          {
            "Name": "Doc",
            "Type": "string",
            "Path": "Field.Doc",
            "Doc": "Doc holds the field doc.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Doc"
          },
          {
            "Name": "Comment",
            "Type": "string",
            "Path": "Field.Comment",
            "Doc": "Comment holds the field comment text.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Comment"
          },
          {
            "Name": "Tag",
            "Type": "string",
            "Path": "Field.Tag",
            "Doc": "Tag is the go tag, unmodified.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Tag"
          },
          {
            "Name": "JSONName",
            "Type": "string",
            "Path": "Field.JSONName",
            "Doc": "JSONName is the corresponding json name of the field.\nIt's cleared if it's set to `-` (unexported).",
            "JSONName": "JSONName"
          },
          {
            "Name": "MapKey",
            "Type": "string",
            "Path": "Field.MapKey",
            "Doc": "MapKey is the map key type, if this field is a map.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "MapKey"
          }
        ],
        "Source": "// Field holds details about a field definition.\ntype Field struct {\n\t// Name is the name of the field.\n\tName\tstring\n\n\t// Type is the literal type of the Go field.\n\tType\tstring\t`json:\",omitempty\"`\n\n\t// Path is the go path of this field starting from root object.\n\tPath\tstring\n\n\t// Doc holds the field doc.\n\tDoc\tstring\t`json:\",omitempty\"`\n\n\t// Comment holds the field comment text.\n\tComment\tstring\t`json:\",omitempty\"`\n\n\t// Tag is the go tag, unmodified.\n\tTag\tstring\t`json:\",omitempty\"`\n\n\t// JSONName is the corresponding json name of the field.\n\t// It's cleared if it's set to `-` (unexported).\n\tJSONName\tstring\n\n\t// MapKey is the map key type, if this field is a map.\n\tMapKey\tstring\t`json:\",omitempty\"`\n}"
      },
      {
        "Kind": "type",
        "Type": "[]*Field",
        "File": "field_list.go",
        "Line": 4,
        "SelfContained": false,
        "Doc": "FieldList contains all struct fields.",
        "Name": "FieldList",
        "Source": "// FieldList contains all struct fields.\ntype FieldList []*Field"
      },
      {
        "Kind": "type",
        "File": "jsonschema.go",
        "Line": 5,
        "SelfContained": false,
        "Doc": "JSONSchema represents a JSON Schema document according to the draft-07 specification.\nIt includes standard fields used to define types, formats, validations.",
        "Name": "JSONSchema",
        "Fields": [
          {
            "Name": "Schema",
            "Type": "string",
            "Path": "JSONSchema.Schema",
            "Doc": "Schema specifies the JSON Schema version URL.\nExample: \"http://json-schema.org/draft-07/schema#\"",
            "Tag": "json:\"$schema,omitempty\"",
            "JSONName": "$schema"
          },
          {
            "Name": "Ref",
            "Type": "string",
            "Path": "JSONSchema.Ref",
            "Doc": "Ref is used to reference another schema definition.\nExample: \"#/definitions/SomeType\"",
            "Tag": "json:\"$ref,omitempty\"",
            "JSONName": "$ref"
          },
          {
            "Name": "Definitions",
            "Type": "map[string]*JSONSchema",
            "Path": "JSONSchema.Definitions",
            "Doc": "Definitions contains subSchema definitions that can be referenced by $ref.",
            "Tag": "json:\"definitions,omitempty\"",
            "JSONName": "definitions"
          },
          {
            "Name": "Type",
            "Type": "string",
            "Path": "JSONSchema.Type",
            "Doc": "Type indicates the JSON type of the instance (e.g., \"object\", \"array\", \"string\").",
            "Tag": "json:\"type,omitempty\"",
            "JSONName": "type"
          },
          {
            "Name": "Format",
            "Type": "string",
            "Path": "JSONSchema.Format",
            "Doc": "Format provides additional semantic validation for the instance.\nCommon formats include \"date-time\", \"email\", etc.",
            "Tag": "json:\"format,omitempty\"",
            "JSONName": "format"
          },
          {
            "Name": "Pattern",
            "Type": "string",
            "Path": "JSONSchema.Pattern",
            "Doc": "Pattern defines a regular expression that a string value must match",
            "Tag": "json:\"pattern,omitempty\"",
            "JSONName": "pattern"
          },
          {
            "Name": "Properties",
            "Type": "map[string]*JSONSchema",
            "Path": "JSONSchema.Properties",
            "Doc": "Properties defines the fields of an object and their corresponding schemas",
            "Tag": "json:\"properties,omitempty\"",
            "JSONName": "properties"
          },
          {
            "Name": "Items",
            "Type": "*JSONSchema",
            "Path": "JSONSchema.Items",
            "Doc": "Items defines the schema for array elements",
            "Tag": "json:\"items,omitempty\"",
            "JSONName": "items"
          },
          {
            "Name": "Enum",
            "Type": "[]any",
            "Path": "JSONSchema.Enum",
            "Doc": "Enum restricts a value to a fixed set of values",
            "Tag": "json:\"enum,omitempty\"",
            "JSONName": "enum"
          },
          {
            "Name": "Required",
            "Type": "[]string",
            "Path": "JSONSchema.Required",
            "Doc": "Required lists the properties that must be present in an object",
            "Tag": "json:\"required,omitempty\"",
            "JSONName": "required"
          },
          {
            "Name": "Description",
            "Type": "string",
            "Path": "JSONSchema.Description",
            "Doc": "Description provides a human-readable explanation of the schema.",
            "Tag": "json:\"description,omitempty\"",
            "JSONName": "description"
          },
          {
            "Name": "Minimum",
            "Type": "*float64",
            "Path": "JSONSchema.Minimum",
            "Doc": "Minimum specifies the minimum numeric value allowed.",
            "Tag": "json:\"minimum,omitempty\"",
            "JSONName": "minimum"
          },
          {
            "Name": "Maximum",
            "Type": "*float64",
            "Path": "JSONSchema.Maximum",
            "Doc": "Maximum specifies the maximum numeric value allowed.",
            "Tag": "json:\"maximum,omitempty\"",
            "JSONName": "maximum"
          },
          {
            "Name": "ExclusiveMinimum",
            "Type": "*bool",
            "Path": "JSONSchema.ExclusiveMinimum",
            "Doc": "ExclusiveMinimum, if true, requires the instance to be greater than (not equal to) Minimum.",
            "Tag": "json:\"exclusiveMinimum,omitempty\"",
            "JSONName": "exclusiveMinimum"
          },
          {
            "Name": "ExclusiveMaximum",
            "Type": "*bool",
            "Path": "JSONSchema.ExclusiveMaximum",
            "Doc": "ExclusiveMaximum, if true, requires the instance to be less than (not equal to) Maximum.",
            "Tag": "json:\"exclusiveMaximum,omitempty\"",
            "JSONName": "exclusiveMaximum"
          },
          {
            "Name": "MultipleOf",
            "Type": "*float64",
            "Path": "JSONSchema.MultipleOf",
            "Doc": "MultipleOf indicates that the numeric instance must be a multiple of this value.",
            "Tag": "json:\"multipleOf,omitempty\"",
            "JSONName": "multipleOf"
          },
          {
            "Name": "AdditionalProperties",
            "Type": "any",
            "Path": "JSONSchema.AdditionalProperties",
            "Doc": "AdditionalProperties controls whether an object can have properties beyond those defined\nCan be a boolean or a schema that additional properties must conform to",
            "Tag": "json:\"additionalProperties,omitempty\"",
            "JSONName": "additionalProperties"
          }
        ],
        "Source": "// JSONSchema represents a JSON Schema document according to the draft-07 specification.\n// It includes standard fields used to define types, formats, validations.\ntype JSONSchema struct {\n\t// Schema specifies the JSON Schema version URL.\n\t// Example: \"http://json-schema.org/draft-07/schema#\"\n\tSchema\tstring\t`json:\"$schema,omitempty\"`\n\t// Ref is used to reference another schema definition.\n\t// Example: \"#/definitions/SomeType\"\n\tRef\tstring\t`json:\"$ref,omitempty\"`\n\t// Definitions contains subSchema definitions that can be referenced by $ref.\n\tDefinitions\tmap[string]*JSONSchema\t`json:\"definitions,omitempty\"`\n\t// Type indicates the JSON type of the instance (e.g., \"object\", \"array\", \"string\").\n\tType\tstring\t`json:\"type,omitempty\"`\n\t// Format provides additional semantic validation for the instance.\n\t// Common formats include \"date-time\", \"email\", etc.\n\tFormat\tstring\t`json:\"format,omitempty\"`\n\t// Pattern defines a regular expression that a string value must match\n\tPattern\tstring\t`json:\"pattern,omitempty\"`\n\t// Properties defines the fields of an object and their corresponding schemas\n\tProperties\tmap[string]*JSONSchema\t`json:\"properties,omitempty\"`\n\t// Items defines the schema for array elements\n\tItems\t*JSONSchema\t`json:\"items,omitempty\"`\n\t// Enum restricts a value to a fixed set of values\n\tEnum\t[]any\t`json:\"enum,omitempty\"`\n\t// Required lists the properties that must be present in an object\n\tRequired\t[]string\t`json:\"required,omitempty\"`\n\t// Description provides a human-readable explanation of the schema.\n\tDescription\tstring\t`json:\"description,omitempty\"`\n\t// Minimum specifies the minimum numeric value allowed.\n\tMinimum\t*float64\t`json:\"minimum,omitempty\"`\n\t// Maximum specifies the maximum numeric value allowed.\n\tMaximum\t*float64\t`json:\"maximum,omitempty\"`\n\t// ExclusiveMinimum, if true, requires the instance to be greater than (not equal to) Minimum.\n\tExclusiveMinimum\t*bool\t`json:\"exclusiveMinimum,omitempty\"`\n\t// ExclusiveMaximum, if true, requires the instance to be less than (not equal to) Maximum.\n\tExclusiveMaximum\t*bool\t`json:\"exclusiveMaximum,omitempty\"`\n\t// MultipleOf indicates that the numeric instance must be a multiple of this value.\n\tMultipleOf\t*float64\t`json:\"multipleOf,omitempty\"`\n\t// AdditionalProperties controls whether an object can have properties beyond those defined\n\t// Can be a boolean or a schema that additional properties must conform to\n\tAdditionalProperties\tany\t`json:\"additionalProperties,omitempty\"`\n}"
      },
      {
        "Kind": "type",
        "File": "package.go",
        "Line": 11,
        "SelfContained": false,
        "Doc": "Package holds go package information.",
        "Name": "Package",
        "Fields": [
          {
            "Name": "ID",
            "Type": "string",
            "Path": "Package.ID",
            "Doc": "ID is the ID of the package as x/tools packages loads it.",
            "JSONName": "ID"
          },
          {
            "Name": "Package",
            "Type": "string",
            "Path": "Package.Package",
            "Doc": "Package is the name of the package.",
            "JSONName": "Package"
          },
          {
            "Name": "ImportPath",
            "Type": "string",
            "Path": "Package.ImportPath",
            "Doc": "ImportPath contains the import path (github...).",
            "JSONName": "ImportPath"
          },
          {
            "Name": "Path",
            "Type": "string",
            "Path": "Package.Path",
            "Doc": "Path is sanitized to contain the relative location (folder).",
            "JSONName": "Path"
          },
          {
            "Name": "TestPackage",
            "Type": "bool",
            "Path": "Package.TestPackage",
            "Doc": "TestPackage is true if this is a test package.",
            "JSONName": "TestPackage"
          },
          {
            "Name": "Complexity",
            "Type": "*Complexity",
            "Path": "Package.Complexity",
            "Doc": "Complexity to collect test coverage on package.",
            "Tag": "json:\",omitempty\"",
            "JSONName": "Complexity"
          },
          {
            "Name": "Pkg",
            "Type": "*packages.Package",
            "Path": "Package.Pkg",
            "Doc": "Pkg serves to carry ast package information, preventing a double Load().\nIt's used during analysis and merging and discarded for the result.",
            "Tag": "json:\"-\"",
            "JSONName": ""
          }
        ],
        "Source": "// Package holds go package information.\ntype Package struct {\n\t// ID is the ID of the package as x/tools packages loads it.\n\tID\tstring\n\t// Package is the name of the package.\n\tPackage\tstring\n\t// ImportPath contains the import path (github...).\n\tImportPath\tstring\n\t// Path is sanitized to contain the relative location (folder).\n\tPath\tstring\n\t// TestPackage is true if this is a test package.\n\tTestPackage\tbool\n\n\t// Complexity to collect test coverage on package.\n\tComplexity\t*Complexity\t`json:\",omitempty\"`\n\n\t// Pkg serves to carry ast package information, preventing a double Load().\n\t// It's used during analysis and merging and discarded for the result.\n\tPkg\t*packages.Package\t`json:\"-\"`\n}"
      },
      {
        "Kind": "type",
        "File": "ref.go",
        "Line": 7,
        "SelfContained": true,
        "Name": "Ref",
        "Fields": [
          {
            "Name": "Package",
            "Type": "*Package",
            "Path": "Ref.Package",
            "JSONName": "Package"
          },
          {
            "Name": "Receiver",
            "Type": "string",
            "Path": "Ref.Receiver",
            "JSONName": "Receiver"
          },
          {
            "Name": "Name",
            "Type": "string",
            "Path": "Ref.Name",
            "JSONName": "Name"
          }
        ],
        "Source": "type Ref struct {\n\tPackage\t\t*Package\n\tReceiver\tstring\n\tName\t\tstring\n}"
      },
      {
        "Kind": "type",
        "Type": "map[string][]string",
        "File": "string_set.go",
        "Line": 13,
        "SelfContained": false,
        "Doc": "StringSet provides a key based unique string slice.",
        "Name": "StringSet",
        "Source": "// StringSet provides a key based unique string slice.\ntype StringSet map[string][]string"
      }
    ],
    "Consts": [
      {
        "Kind": "const",
        "File": "declaration_kind.go",
        "Line": 6,
        "SelfContained": false,
        "Names": [
          "StructKind",
          "ImportKind",
          "ConstKind",
          "TypeKind",
          "FuncKind",
          "VarKind",
          "CommentKind"
        ],
        "Source": "const (\n\tStructKind\tDeclarationKind\t= \"struct\"\n\tImportKind\t\t\t= \"import\"\n\tConstKind\t\t\t= \"const\"\n\tTypeKind\t\t\t= \"type\"\n\tFuncKind\t\t\t= \"func\"\n\tVarKind\t\t\t\t= \"var\"\n\tCommentKind\t\t\t= \"comment\"\n)"
      }
    ],
    "Vars": [
      {
        "Kind": "var",
        "File": "built_in_types.go",
        "Line": 40,
        "SelfContained": true,
        "Name": "BuiltInTypes",
        "Source": "var BuiltInTypes = map[string]bool{\n\t\"string\":\ttrue,\n\t\"int\":\t\ttrue,\n\t\"int8\":\t\ttrue,\n\t\"int16\":\ttrue,\n\t\"int32\":\ttrue,\n\t\"int64\":\ttrue,\n\t\"uint\":\t\ttrue,\n\t\"uint8\":\ttrue,\n\t\"uint16\":\ttrue,\n\t\"uint32\":\ttrue,\n\t\"uint64\":\ttrue,\n\t\"uintptr\":\ttrue,\n\t\"float32\":\ttrue,\n\t\"float64\":\ttrue,\n\t\"complex64\":\ttrue,\n\t\"complex128\":\ttrue,\n\t\"byte\":\t\ttrue,\n\t\"rune\":\t\ttrue,\n\t\"bool\":\t\ttrue,\n\t\"error\":\ttrue,\n\t\"interface{}\":\ttrue,\n}"
      }
    ],
    "Funcs": [
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 15,
        "SelfContained": false,
        "Name": "NewStringSet",
        "Returns": [
          "StringSet"
        ],
        "Signature": "NewStringSet () StringSet",
        "Source": "func NewStringSet() StringSet {\n\treturn make(StringSet)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "built_in_types.go",
        "Line": 8,
        "SelfContained": false,
        "References": {
          "strings": [
            "TrimLeft",
            "HasPrefix",
            "Contains",
            "SplitN"
          ]
        },
        "Doc": "To type returns a sanitized type name.",
        "Name": "ToType",
        "Arguments": [
          "string"
        ],
        "Returns": [
          "string",
          "bool"
        ],
        "Signature": "ToType (s string) (string, bool)",
        "Source": "// To type returns a sanitized type name.\nfunc ToType(s string) (string, bool) {\n\t// variadic ...\n\ts = strings.TrimLeft(s, \".\")\n\t// functions\n\tif strings.HasPrefix(s, \"func\") {\n\t\treturn \"\u003cfunc\u003e\", false\n\t}\n\t// channels\n\t// implementation gap: anonymous structs\n\tif strings.Contains(s, \" \") {\n\t\tss := strings.SplitN(s, \" \", 2)\n\t\tif strings.Contains(ss[0], \"chan\") {\n\t\t\ts = ss[1]\n\t\t}\n\t}\n\t// maps, slices\n\tfor strings.Contains(s, \"]\") {\n\t\t// Handle:\n\t\t// - `[]` V\n\t\t// - `map[...]` V\n\t\t// - `.*]` V\n\t\tss := strings.SplitN(s, \"]\", 2)\n\t\ts = ss[len(ss)-1]\n\t}\n\t// *T to T\n\ts = strings.TrimLeft(s, \"*\")\n\tif yes, _ := BuiltInTypes[s]; yes {\n\t\treturn s, false\n\t}\n\treturn s, true\n}",
        "Complexity": {
          "Cognitive": 6,
          "Cyclomatic": 6,
          "Lines": 32
        }
      },
      {
        "Kind": "func",
        "File": "type_ref.go",
        "Line": 8,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasPrefix",
            "SplitN",
            "TrimPrefix"
          ]
        },
        "Doc": "TypeRef aims to trim a type name to a reference type.",
        "Name": "TypeRef",
        "Arguments": [
          "string"
        ],
        "Returns": [
          "string"
        ],
        "Signature": "TypeRef (name string) string",
        "Source": "// TypeRef aims to trim a type name to a reference type.\nfunc TypeRef(name string) string {\n\t// trim variadic arg\n\tif strings.HasPrefix(name, \"...\") {\n\t\tname = name[3:]\n\t}\n\n\t// slice, array and map value\n\t// in terms of nesting, this is a hack\n\tif strings.HasPrefix(name, \"[\") || strings.HasPrefix(name, \"map[\") {\n\t\tname = strings.SplitN(name, \"]\", 2)[1]\n\t}\n\n\t// deref pointers\n\treturn strings.TrimPrefix(name, \"*\")\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 4,
          "Lines": 16
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 106,
        "SelfContained": false,
        "Name": "Equal",
        "Receiver": "*Declaration",
        "Arguments": [
          "*Declaration"
        ],
        "Returns": [
          "bool"
        ],
        "Signature": "Equal (in *Declaration) bool",
        "Source": "func (d *Declaration) Equal(in *Declaration) bool {\n\tif d.File == in.File \u0026\u0026 d.Kind == in.Kind \u0026\u0026 d.Name == in.Name {\n\t\treturn true\n\t}\n\treturn false\n}",
        "Complexity": {
          "Cognitive": 2,
          "Cyclomatic": 4,
          "Lines": 6
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 77,
        "SelfContained": false,
        "Name": "GetNames",
        "Receiver": "*Declaration",
        "Returns": [
          "[]string"
        ],
        "Signature": "GetNames () []string",
        "Source": "func (d *Declaration) GetNames() []string {\n\tif len(d.Names) \u003e 0 {\n\t\treturn d.Names\n\t}\n\treturn []string{d.Name}\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 6
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 84,
        "SelfContained": false,
        "Name": "HasName",
        "Receiver": "*Declaration",
        "Arguments": [
          "string"
        ],
        "Returns": [
          "bool"
        ],
        "Signature": "HasName (find string) bool",
        "Source": "func (d *Declaration) HasName(find string) bool {\n\tfor _, name := range d.Names {\n\t\tif name == find {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn d.Name == find\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 45,
        "SelfContained": false,
        "Name": "HasReceiver",
        "Receiver": "*Declaration",
        "Returns": [
          "bool"
        ],
        "Signature": "HasReceiver () bool",
        "Source": "func (f *Declaration) HasReceiver() bool {\n\treturn f.Receiver != \"\"\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 93,
        "SelfContained": false,
        "References": {
          "ast": [
            "IsExported"
          ]
        },
        "Name": "IsExported",
        "Receiver": "*Declaration",
        "Returns": [
          "bool"
        ],
        "Signature": "IsExported () bool",
        "Source": "func (d *Declaration) IsExported() bool {\n\tif d.Receiver != \"\" \u0026\u0026 !ast.IsExported(TypeRef(d.Receiver)) {\n\t\treturn false\n\t}\n\n\tfor _, name := range d.Names {\n\t\tif ast.IsExported(name) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn ast.IsExported(d.Name)\n}",
        "Complexity": {
          "Cognitive": 5,
          "Cyclomatic": 5,
          "Lines": 12
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 41,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasSuffix"
          ]
        },
        "Name": "IsTestScope",
        "Receiver": "*Declaration",
        "Returns": [
          "bool"
        ],
        "Signature": "IsTestScope () bool",
        "Source": "func (f *Declaration) IsTestScope() bool {\n\treturn strings.HasSuffix(f.File, \"_test.go\")\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 113,
        "SelfContained": false,
        "References": {
          "strings": [
            "Trim"
          ]
        },
        "Name": "Keys",
        "Receiver": "*Declaration",
        "Returns": [
          "[]string"
        ],
        "Signature": "Keys () []string",
        "Source": "func (d *Declaration) Keys() []string {\n\ttrimPath := \"*.\"\n\tif d.Name != \"\" {\n\t\treturn []string{\n\t\t\tstrings.Trim(d.Receiver+\".\"+d.Name, trimPath),\n\t\t}\n\t}\n\tif len(d.Names) != 0 {\n\t\tresult := make([]string, len(d.Names))\n\t\tfor k, v := range d.Names {\n\t\t\tresult[k] = strings.Trim(d.Receiver+\".\"+v, trimPath)\n\t\t}\n\t\treturn result\n\t}\n\treturn nil\n}",
        "Complexity": {
          "Cognitive": 4,
          "Cyclomatic": 4,
          "Lines": 16
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 73,
        "SelfContained": false,
        "Name": "ReceiverTypeRef",
        "Receiver": "*Declaration",
        "Returns": [
          "string"
        ],
        "Signature": "ReceiverTypeRef () string",
        "Source": "func (f *Declaration) ReceiverTypeRef() string {\n\treturn TypeRef(f.Receiver)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 49,
        "SelfContained": false,
        "Name": "Ref",
        "Receiver": "*Declaration",
        "Arguments": [
          "*Package"
        ],
        "Returns": [
          "[]Ref"
        ],
        "Signature": "Ref (pkg *Package) []Ref",
        "Source": "func (f *Declaration) Ref(pkg *Package) []Ref {\n\treceiver := f.ReceiverTypeRef()\n\tresult := make([]Ref, 0, len(f.Names)+1)\n\tfor _, name := range f.Names {\n\t\tresult = append(result, Ref{\n\t\t\tPackage:\tpkg,\n\t\t\tName:\t\tname,\n\t\t\tReceiver:\treceiver,\n\t\t})\n\t}\n\n\tresult = append(result, Ref{\n\t\tPackage:\tpkg,\n\t\tName:\t\tf.Name,\n\t\tReceiver:\treceiver,\n\t})\n\n\treturn result\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 19
        }
      },
      {
        "Kind": "func",
        "File": "declaration.go",
        "Line": 69,
        "SelfContained": false,
        "Name": "TypeRef",
        "Receiver": "*Declaration",
        "Returns": [
          "string"
        ],
        "Signature": "TypeRef () string",
        "Source": "func (f *Declaration) TypeRef() string {\n\treturn TypeRef(f.Type)\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 12,
        "SelfContained": false,
        "Name": "Append",
        "Receiver": "*DeclarationList",
        "Arguments": [
          "...*Declaration"
        ],
        "Signature": "Append (in ...*Declaration)",
        "Source": "func (p *DeclarationList) Append(in ...*Declaration) {\n\t*p = append(*p, in...)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 16,
        "SelfContained": false,
        "Name": "AppendUnique",
        "Receiver": "*DeclarationList",
        "Arguments": [
          "...*Declaration"
        ],
        "Signature": "AppendUnique (in ...*Declaration)",
        "Source": "func (p *DeclarationList) AppendUnique(in ...*Declaration) {\n\tfor _, i := range in {\n\t\tshouldAppend := true\n\t\tfor _, decl := range *p {\n\t\t\tif decl.Equal(i) {\n\t\t\t\tshouldAppend = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif shouldAppend {\n\t\t\t*p = append(*p, i)\n\t\t}\n\t}\n\tp.Sort()\n}",
        "Complexity": {
          "Cognitive": 8,
          "Cyclomatic": 5,
          "Lines": 16
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 83,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasSuffix"
          ]
        },
        "Name": "ClearNonTestFiles",
        "Receiver": "*DeclarationList",
        "Signature": "ClearNonTestFiles ()",
        "Source": "func (p *DeclarationList) ClearNonTestFiles() {\n\tresult := DeclarationList{}\n\tfor _, decl := range *p {\n\t\tif !strings.HasSuffix(decl.File, \"_test.go\") {\n\t\t\tcontinue\n\t\t}\n\t\tresult.Append(decl)\n\t}\n\t*p = result\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 10
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 66,
        "SelfContained": false,
        "Name": "ClearSource",
        "Receiver": "*DeclarationList",
        "Signature": "ClearSource ()",
        "Source": "func (p *DeclarationList) ClearSource() {\n\tfor _, decl := range *p {\n\t\tdecl.Source = \"\"\n\t}\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 5
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 72,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasSuffix"
          ]
        },
        "Name": "ClearTestFiles",
        "Receiver": "*DeclarationList",
        "Signature": "ClearTestFiles ()",
        "Source": "func (p *DeclarationList) ClearTestFiles() {\n\tresult := DeclarationList{}\n\tfor _, decl := range *p {\n\t\tif strings.HasSuffix(decl.File, \"_test.go\") {\n\t\t\tcontinue\n\t\t}\n\t\tresult.Append(decl)\n\t}\n\t*p = result\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 10
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 94,
        "SelfContained": false,
        "References": {
          "ast": [
            "IsExported"
          ],
          "sort": [
            "Slice"
          ]
        },
        "Name": "Sort",
        "Receiver": "*DeclarationList",
        "Signature": "Sort ()",
        "Source": "func (p *DeclarationList) Sort() {\n\tsort.Slice(*p, func(i, j int) bool {\n\t\ta, b := (*p)[i], (*p)[j]\n\t\tif a.Kind != b.Kind {\n\t\t\tindexOf := map[DeclarationKind]int{\n\t\t\t\tCommentKind:\t0,\n\t\t\t\tImportKind:\t1,\n\t\t\t\tConstKind:\t2,\n\t\t\t\tStructKind:\t3,\n\t\t\t\tTypeKind:\t4,\n\t\t\t\tVarKind:\t5,\n\t\t\t\tFuncKind:\t6,\n\t\t\t}\n\t\t\treturn indexOf[a.Kind] \u003c indexOf[b.Kind]\n\t\t}\n\t\tae, be := ast.IsExported(a.Name), ast.IsExported(b.Name)\n\t\tif ae != be {\n\t\t\treturn ae\n\t\t}\n\n\t\tif a.Receiver != b.Receiver {\n\t\t\tif a.Receiver == \"\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn a.Receiver \u003c b.Receiver\n\t\t}\n\n\t\tif a.Signature != b.Signature {\n\t\t\treturn a.Signature \u003c b.Signature\n\t\t}\n\n\t\treturn a.Name \u003c b.Name\n\t})\n}",
        "Complexity": {
          "Cognitive": 11,
          "Cyclomatic": 6,
          "Lines": 34
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 68,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasSuffix"
          ]
        },
        "Name": "ClearNonTestFiles",
        "Receiver": "*Definition",
        "Signature": "ClearNonTestFiles ()",
        "Source": "func (d *Definition) ClearNonTestFiles() {\n\tfor filename, _ := range d.Imports {\n\t\tif !strings.HasSuffix(filename, \"_test.go\") {\n\t\t\tdelete(d.Imports, filename)\n\t\t}\n\t}\n\td.Types.ClearNonTestFiles()\n\td.Vars.ClearNonTestFiles()\n\td.Consts.ClearNonTestFiles()\n\td.Funcs.ClearNonTestFiles()\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 11
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 49,
        "SelfContained": false,
        "Name": "ClearSource",
        "Receiver": "*Definition",
        "Signature": "ClearSource ()",
        "Source": "func (d *Definition) ClearSource() {\n\td.Types.ClearSource()\n\td.Vars.ClearSource()\n\td.Consts.ClearSource()\n\td.Funcs.ClearSource()\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 6
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 56,
        "SelfContained": false,
        "References": {
          "strings": [
            "HasSuffix"
          ]
        },
        "Name": "ClearTestFiles",
        "Receiver": "*Definition",
        "Signature": "ClearTestFiles ()",
        "Source": "func (d *Definition) ClearTestFiles() {\n\tfor filename, _ := range d.Imports {\n\t\tif strings.HasSuffix(filename, \"_test.go\") {\n\t\t\tdelete(d.Imports, filename)\n\t\t}\n\t}\n\td.Types.ClearTestFiles()\n\td.Vars.ClearTestFiles()\n\td.Consts.ClearTestFiles()\n\td.Funcs.ClearTestFiles()\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 11
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 21,
        "SelfContained": false,
        "Doc": "DeclarationList merges all the declarations together.",
        "Name": "DeclarationList",
        "Receiver": "*Definition",
        "Returns": [
          "DeclarationList"
        ],
        "Signature": "DeclarationList () DeclarationList",
        "Source": "// DeclarationList merges all the declarations together.\nfunc (d *Definition) DeclarationList() DeclarationList {\n\tallDecls := DeclarationList{}\n\tallDecls.Append(d.Consts...)\n\tallDecls.Append(d.Vars...)\n\tallDecls.Append(d.Types...)\n\tallDecls.Append(d.Funcs...)\n\treturn allDecls\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 9
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 80,
        "SelfContained": false,
        "Name": "Fill",
        "Receiver": "*Definition",
        "Signature": "Fill ()",
        "Source": "func (d *Definition) Fill() {\n\tfor _, decl := range d.Order() {\n\t\tdecl.Imports = d.getImports(decl)\n\t}\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 5
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 86,
        "SelfContained": false,
        "Name": "Merge",
        "Receiver": "*Definition",
        "Arguments": [
          "*Definition"
        ],
        "Signature": "Merge (in *Definition)",
        "Source": "func (d *Definition) Merge(in *Definition) {\n\td.TestPackage = d.TestPackage || in.TestPackage\n\n\tfor k, v := range in.Imports {\n\t\td.Imports.Add(k, v...)\n\t}\n\n\td.Types.AppendUnique(in.Types...)\n\td.Funcs.AppendUnique(in.Funcs...)\n\td.Vars.AppendUnique(in.Vars...)\n\td.Consts.AppendUnique(in.Consts...)\n\n\t// this line causes Sort to be omitted from the\n\t// definitions :/ ... solved by adding the sort\n\t// in the AppendUnique above, but the Sort symbol\n\t// should not be omitted from Definition.\n\n\t// d.Sort()\n}",
        "Complexity": {
          "Cognitive": 2,
          "Cyclomatic": 3,
          "Lines": 19
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 38,
        "SelfContained": false,
        "Name": "Order",
        "Receiver": "*Definition",
        "Returns": [
          "DeclarationList"
        ],
        "Signature": "Order () DeclarationList",
        "Source": "func (d *Definition) Order() DeclarationList {\n\tcount := len(d.Types) + len(d.Funcs) + len(d.Vars) + len(d.Consts)\n\tresult := make([]*Declaration, 0, count)\n\n\tresult = append(result, d.Types...)\n\tresult = append(result, d.Funcs...)\n\tresult = append(result, d.Vars...)\n\tresult = append(result, d.Consts...)\n\treturn DeclarationList(result)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 10
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 31,
        "SelfContained": false,
        "Doc": "Sort will sort the inner types so they have a stable order.",
        "Name": "Sort",
        "Receiver": "*Definition",
        "Signature": "Sort ()",
        "Source": "// Sort will sort the inner types so they have a stable order.\nfunc (d *Definition) Sort() {\n\td.Types.Sort()\n\td.Vars.Sort()\n\td.Consts.Sort()\n\td.Funcs.Sort()\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 7
        }
      },
      {
        "Kind": "func",
        "File": "field.go",
        "Line": 31,
        "SelfContained": false,
        "Name": "TypeRef",
        "Receiver": "*Field",
        "Returns": [
          "string"
        ],
        "Signature": "TypeRef () string",
        "Source": "func (f *Field) TypeRef() string {\n\treturn TypeRef(f.Type)\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 36,
        "SelfContained": false,
        "References": {
          "slices": [
            "Contains"
          ]
        },
        "Name": "Add",
        "Receiver": "*StringSet",
        "Arguments": [
          "string",
          "...string"
        ],
        "Signature": "Add (key string, lits ...string)",
        "Source": "func (i *StringSet) Add(key string, lits ...string) {\n\tdata := *i\n\tif data == nil {\n\t\tdata = make(StringSet)\n\t}\n\tif set, ok := data[key]; ok {\n\t\tfor _, lit := range lits {\n\t\t\tif slices.Contains(set, lit) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tset = append(set, lit)\n\t\t}\n\n\t\tdata[key] = set\n\t\treturn\n\t}\n\tdata[key] = lits[:]\n\t*i = data\n}",
        "Complexity": {
          "Cognitive": 7,
          "Cyclomatic": 5,
          "Lines": 19
        }
      },
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 19,
        "SelfContained": false,
        "References": {
          "sort": [
            "Strings"
          ]
        },
        "Name": "Keys",
        "Receiver": "*StringSet",
        "Returns": [
          "[]string"
        ],
        "Signature": "Keys () []string",
        "Source": "func (i *StringSet) Keys() []string {\n\tkeys := make([]string, 0, len(*i))\n\tfor key := range *i {\n\t\tkeys = append(keys, key)\n\t}\n\n\tvar m = *i\n\n\tfor k, v := range m {\n\t\tsort.Strings(v)\n\t\tm[k] = v\n\t}\n\n\tsort.Strings(keys)\n\treturn keys\n}",
        "Complexity": {
          "Cognitive": 2,
          "Cyclomatic": 3,
          "Lines": 16
        }
      },
      {
        "Kind": "func",
        "File": "declaration_kind.go",
        "Line": 16,
        "SelfContained": false,
        "Name": "String",
        "Receiver": "DeclarationKind",
        "Returns": [
          "string"
        ],
        "Signature": "String () string",
        "Source": "func (d DeclarationKind) String() string {\n\treturn string(d)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 33,
        "SelfContained": false,
        "Name": "Exported",
        "Receiver": "DeclarationList",
        "Returns": [
          "DeclarationList"
        ],
        "Signature": "Exported () DeclarationList",
        "Source": "func (p DeclarationList) Exported() (result DeclarationList) {\n\tfor _, decl := range p {\n\t\tif decl.IsExported() {\n\t\t\tresult = append(result, decl)\n\t\t}\n\t}\n\treturn\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 57,
        "SelfContained": false,
        "Name": "Filter",
        "Receiver": "DeclarationList",
        "Arguments": [
          "func(d *Declaration) bool"
        ],
        "Returns": [
          "DeclarationList"
        ],
        "Signature": "Filter (matchfn func(d *Declaration) bool) DeclarationList",
        "Source": "func (p DeclarationList) Filter(matchfn func(d *Declaration) bool) (result DeclarationList) {\n\tfor _, decl := range p {\n\t\tif matchfn(decl) {\n\t\t\tresult.Append(decl)\n\t\t}\n\t}\n\treturn\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 48,
        "SelfContained": false,
        "Name": "Find",
        "Receiver": "DeclarationList",
        "Arguments": [
          "func(d *Declaration) bool"
        ],
        "Returns": [
          "*Declaration"
        ],
        "Signature": "Find (matchfn func(d *Declaration) bool) *Declaration",
        "Source": "func (p DeclarationList) Find(matchfn func(d *Declaration) bool) *Declaration {\n\tfor _, decl := range p {\n\t\tif matchfn(decl) {\n\t\t\treturn decl\n\t\t}\n\t}\n\treturn nil\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "declaration_list.go",
        "Line": 42,
        "SelfContained": false,
        "Name": "Walk",
        "Receiver": "DeclarationList",
        "Arguments": [
          "func(d *Declaration)"
        ],
        "Signature": "Walk (matchfn func(d *Declaration))",
        "Source": "func (p DeclarationList) Walk(matchfn func(d *Declaration)) {\n\tfor _, decl := range p {\n\t\tmatchfn(decl)\n\t}\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 5
        }
      },
      {
        "Kind": "func",
        "File": "definition_list.go",
        "Line": 21,
        "SelfContained": false,
        "Name": "Filter",
        "Receiver": "DefinitionList",
        "Arguments": [
          "func(d *Definition) bool"
        ],
        "Returns": [
          "[]*Definition"
        ],
        "Signature": "Filter (matchfn func(d *Definition) bool) []*Definition",
        "Source": "func (p DefinitionList) Filter(matchfn func(d *Definition) bool) (result []*Definition) {\n\tfor _, decl := range p {\n\t\tif matchfn(decl) {\n\t\t\tresult = append(result, decl)\n\t\t}\n\t}\n\treturn\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "definition_list.go",
        "Line": 12,
        "SelfContained": false,
        "Name": "Find",
        "Receiver": "DefinitionList",
        "Arguments": [
          "func(d *Definition) bool"
        ],
        "Returns": [
          "*Definition"
        ],
        "Signature": "Find (matchfn func(d *Definition) bool) *Definition",
        "Source": "func (p DefinitionList) Find(matchfn func(d *Definition) bool) *Definition {\n\tfor _, decl := range p {\n\t\tif matchfn(decl) {\n\t\t\treturn decl\n\t\t}\n\t}\n\treturn nil\n}",
        "Complexity": {
          "Cognitive": 3,
          "Cyclomatic": 3,
          "Lines": 8
        }
      },
      {
        "Kind": "func",
        "File": "definition_list.go",
        "Line": 6,
        "SelfContained": false,
        "Name": "Walk",
        "Receiver": "DefinitionList",
        "Arguments": [
          "func(d *Definition)"
        ],
        "Signature": "Walk (matchfn func(d *Definition))",
        "Source": "func (p DefinitionList) Walk(matchfn func(d *Definition)) {\n\tfor _, decl := range p {\n\t\tmatchfn(decl)\n\t}\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 5
        }
      },
      {
        "Kind": "func",
        "File": "package.go",
        "Line": 39,
        "SelfContained": false,
        "Name": "Equal",
        "Receiver": "Package",
        "Arguments": [
          "Package"
        ],
        "Returns": [
          "bool"
        ],
        "Signature": "Equal (in Package) bool",
        "Source": "func (p Package) Equal(in Package) bool {\n\treturn p.ImportPath == in.ImportPath\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "package.go",
        "Line": 31,
        "SelfContained": false,
        "Name": "Name",
        "Receiver": "Package",
        "Returns": [
          "string"
        ],
        "Signature": "Name () string",
        "Source": "func (p Package) Name() string {\n\treturn p.Package\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "package.go",
        "Line": 43,
        "SelfContained": false,
        "References": {
          "strings": [
            "Trim",
            "ReplaceAll"
          ]
        },
        "Name": "Namespace",
        "Receiver": "Package",
        "Arguments": [
          "string"
        ],
        "Returns": [
          "string"
        ],
        "Signature": "Namespace (suffix string) string",
        "Source": "func (p Package) Namespace(suffix string) string {\n\tvar namespace string\n\tpackagePath := strings.Trim(p.Path, \"./\")\n\tif packagePath != \"\" {\n\t\tnamespace = strings.ReplaceAll(packagePath, \"/\", \".\")\n\t}\n\tif namespace == \"\" {\n\t\tnamespace = p.Package\n\t}\n\treturn namespace + suffix\n}",
        "Complexity": {
          "Cognitive": 2,
          "Cyclomatic": 3,
          "Lines": 11
        }
      },
      {
        "Kind": "func",
        "File": "package.go",
        "Line": 35,
        "SelfContained": false,
        "References": {
          "fmt": [
            "Sprintf"
          ]
        },
        "Name": "String",
        "Receiver": "Package",
        "Returns": [
          "string"
        ],
        "Signature": "String () string",
        "Source": "func (p Package) String() string {\n\treturn fmt.Sprintf(\"package=%s import_path=%s path=%s test_package=%v\", p.Package, p.ImportPath, p.Path, p.TestPackage)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      },
      {
        "Kind": "func",
        "File": "ref.go",
        "Line": 13,
        "SelfContained": false,
        "References": {
          "fmt": [
            "Sprintf"
          ]
        },
        "Name": "String",
        "Receiver": "Ref",
        "Returns": [
          "string"
        ],
        "Signature": "String () string",
        "Source": "func (r Ref) String() string {\n\tif r.Receiver != \"\" {\n\t\treturn fmt.Sprintf(\"%s.%s.%s\", r.Package.Name(), TypeRef(r.Receiver), TypeRef(r.Name))\n\t}\n\treturn fmt.Sprintf(\"%s.%s\", r.Package.Name(), TypeRef(r.Name))\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 6
        }
      },
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 64,
        "SelfContained": false,
        "Name": "All",
        "Receiver": "StringSet",
        "Returns": [
          "[]string"
        ],
        "Signature": "All () []string",
        "Source": "func (i StringSet) All() []string {\n\tresult := []string{}\n\tfor _, set := range i {\n\t\tresult = append(result, set...)\n\t}\n\treturn result\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 7
        }
      },
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 56,
        "SelfContained": false,
        "References": {
          "sort": [
            "Strings"
          ]
        },
        "Name": "Get",
        "Receiver": "StringSet",
        "Arguments": [
          "string"
        ],
        "Returns": [
          "[]string"
        ],
        "Signature": "Get (key string) []string",
        "Source": "func (i StringSet) Get(key string) []string {\n\tval, _ := i[key]\n\tif val != nil {\n\t\tsort.Strings(val)\n\t}\n\treturn val\n}",
        "Complexity": {
          "Cognitive": 1,
          "Cyclomatic": 2,
          "Lines": 7
        }
      },
      {
        "Kind": "func",
        "File": "string_set.go",
        "Line": 74,
        "SelfContained": false,
        "References": {
          "fmt": [
            "Errorf"
          ],
          "path": [
            "Base"
          ],
          "regexp": [
            "MustCompile"
          ],
          "strings": [
            "ReplaceAll",
            "Contains",
            "Split",
            "Trim",
            "HasSuffix"
          ]
        },
        "Doc": "Map returns a map with the short package name as the key\nand the full import path as the value.",
        "Name": "Map",
        "Receiver": "StringSet",
        "Arguments": [
          "[]string"
        ],
        "Returns": [
          "map[string]string",
          "[]error"
        ],
        "Signature": "Map (imports []string) (map[string]string, []error)",
        "Source": "// Map returns a map with the short package name as the key\n// and the full import path as the value.\nfunc (i StringSet) Map(imports []string) (map[string]string, []error) {\n\twarnings := []error{}\n\twarningSeen := map[string]bool{}\n\n\taddWarning := func(warning error) {\n\t\tmsg := warning.Error()\n\t\tif _, seen := warningSeen[msg]; !seen {\n\t\t\twarningSeen[msg] = true\n\t\t\twarnings = append(warnings, warning)\n\t\t}\n\t}\n\n\tcleanPackageName := func(name string) (string, bool) {\n\t\tclean := name\n\t\tclean = strings.ReplaceAll(clean, \"_\", \"\")\n\t\treturn clean, name == clean\n\t}\n\n\tresult := map[string]string{}\n\tfor _, imported := range imports {\n\t\tvar short, long string\n\n\t\t// aliased package\n\t\t// imported = strings.ReplaceAll(imported, \"/go-\", \"/\")\n\t\tif strings.Contains(imported, \" \") {\n\t\t\tline := strings.Split(imported, \" \")\n\t\t\tshort, long = line[0], strings.Trim(line[1], `\"`)\n\t\t} else {\n\t\t\tlong = strings.Trim(imported, `\"`)\n\t\t\tshort = path.Base(long)\n\t\t}\n\n\t\tif short == \"C\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// trim imported semver link\n\t\tre := regexp.MustCompile(`/v[0-9]+$`)\n\t\tif re.MatchString(long) {\n\t\t\tshort = path.Base(re.ReplaceAllString(long, \"\"))\n\t\t}\n\n\t\tif strings.HasSuffix(short, \"_test\") {\n\t\t\tclean, ok := cleanPackageName(short[:len(short)-5])\n\t\t\tif !ok {\n\t\t\t\taddWarning(fmt.Errorf(\"Alias %s should be %s_test\", short, clean))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tclean, ok := cleanPackageName(short)\n\t\tif !ok {\n\t\t\taddWarning(fmt.Errorf(\"Alias %s should be %s\", short, clean))\n\t\t\tcontinue\n\t\t}\n\n\t\tval, ok := result[clean]\n\n\t\tif ok \u0026\u0026 val != long {\n\t\t\twarning := \"Import conflict for %s, \"\n\t\t\t// Sort val/long so shorter is left hand side\n\t\t\tif len(val) \u003c len(long) {\n\t\t\t\twarning += val + \" != \" + long\n\t\t\t} else {\n\t\t\t\twarning += long + \" != \" + val\n\t\t\t}\n\t\t\taddWarning(fmt.Errorf(warning, short))\n\t\t}\n\n\t\tresult[clean] = long\n\t}\n\n\treturn result, warnings\n}",
        "Complexity": {
          "Cognitive": 24,
          "Cyclomatic": 12,
          "Lines": 76
        }
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Line": 106,
        "SelfContained": false,
        "Name": "getImports",
        "Receiver": "*Definition",
        "Arguments": [
          "*Declaration"
        ],
        "Returns": [
          "[]string"
        ],
        "Signature": "getImports (decl *Declaration) []string",
        "Source": "func (d *Definition) getImports(decl *Declaration) []string {\n\treturn d.Imports.Get(decl.File)\n}",
        "Complexity": {
          "Cognitive": 0,
          "Cyclomatic": 1,
          "Lines": 3
        }
      }
    ]
  }
]
